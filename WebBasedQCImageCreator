#!/usr/bin/python

import sys
import os
import traceback
import shutil
import tempfile
import StringIO
import numpy
import PIL.Image
import dicom
import nibabel
import xnat

class GeneratorError(Exception):

    "exception for generators rejecting scans"

    def __init__(self, reason):
        self.reason = reason
        return

    def __str__(self):
        return self.reason

class Scan:

    def __repr__(self):
        return '<Scan %s>' % self.id

    def remove_copies(self):
        if self.copy_dir:
            shutil.rmtree(self.copy_dir)
            self.copy_dir = None
        return

    def save_image(self, im):
        fname = '%s_%s_qc.gif' % (self.session_id, self.id)
        self.save_single_image(im, 'SNAPSHOTS', fname, 'ORIGINAL')
        fname = '%s_%s_qc_t.gif' % (self.session_id, self.id)
        half_size = [ s/2 for s in im.size ]
        im2 = im.resize(half_size)
        self.save_single_image(im2, 'SNAPSHOTS', fname, 'THUMBNAIL')
        return

    def files(self, resource):
        if self.copy_dir is None:
            self.copy_resource(resource)
        resource_dir = '%s/%s' % (self.copy_dir, resource)
        if not os.path.exists(resource_dir):
            self.copy_resource(resource)
        for fname in os.listdir(resource_dir):
            yield '%s/%s' % (resource_dir, fname)
        return

class DirScan(Scan):

    def __init__(self, session_id, dir):
        self.session_id = session_id
        self.dir = dir
        self.id = os.path.basename(dir)
        self.resources = os.listdir(dir)
        self.copy_dir = None
        return

    def copy_resource(self, resource):
        if resource not in self.resources:
            raise ValueError('no resource %s' % resource)
        if not self.copy_dir:
            self.copy_dir = tempfile.mkdtemp()
        copy_dir = '%s/%s' % (self.copy_dir, resource)
        if os.path.exists(copy_dir):
            return
        shutil.copytree('%s/%s' % (self.dir, resource), copy_dir)
        return

    def save_single_image(self, im, resource, fname, content):
        resource_dir = '%s/%s' % (self.dir, resource)
        if not os.path.exists(resource_dir):
            os.mkdir(resource_dir)
        fo = open('%s/%s' % (resource_dir, fname), 'w')
        im.save(fo, format='GIF')
        fo.close()
        return

class XNATScan(Scan):

    def __init__(self, session_id, xnat_scan):
        self.session_id = session_id
        self.xnat_scan = xnat_scan
        self.id = self.xnat_scan.id
        self.resources = self.xnat_scan.resources
        return

    def save_single_image(self, im, resource, fname, content):
        xnat_resource = self.xnat_scan.resources[resource]
        if fname in xnat_resource.files:
            xnat_resource.files[fname].delete()
        buf = StringIO.StringIO()
        im.save(buf, format='GIF')
        xnat_resource.create_file(buf.getvalue(), 
                                  fname, 
                                  format='GIF', 
                                  content=content)
        buf.close()
        return

class TiledImage:

    """Tiled image generator

    usage:

    ti = TiledImage()
    ti.add_frame(0, 0, im) # im is a PIL.Image.Image instance)
    ti.add_frame(1, 0, im) # im.mode and im.shape is checked against the first
    ...
    ti.add_frame(n_x-1, n_y-1, im)
    im = ti.generate() # generates a PIL.Image.Image
    """

    tile_cols = 5
    tile_rows = 5

    # may actually be smaller if the passed frames are smaller
    target_frame_side = 140

    def __init__(self):
        # frames are addressed by frames[col][row]
        self.frames = []
        for c in range(self.tile_cols):
            self.frames.append(self.tile_rows * [None])
        self.ref_image = None
        return

    def __len__(self):
        "total number of frames"
        return self.tile_cols * self.tile_rows

    def add_frame(self, spec, im):
        if isinstance(spec, tuple):
            (col, row) = spec
        elif isinstance(spec, int):
            col = spec % self.tile_cols
            row = (spec-col) / self.tile_rows
        else:
            raise TypeError, 'spec must be a (col, row) tuple or an integer'
        if col < 0 or col >= self.tile_cols:
            raise IndexError, 'col out of range'
        if row < 0 or row >= self.tile_rows:
            raise IndexError, 'row out of range'
        if self.ref_image:
            if self.frames[col][row]:
                raise ValueError, 'image already set for (%d, %d)' % (col, row)
            if im.mode != self.ref_image.mode:
                raise ValueError, 'mode mismatch (%s, expecting %s)' % (im.mode, self.ref_image.mode)
            if im.size != self.ref_image.size:
                raise ValueError, 'size mismatch (%s, expecting %s)' % (str(im.size), str(self.ref_image.size))
        else:
            self.ref_image = im
        self.frames[col][row] = im
        return

    def generate(self):
        if not self.ref_image:
            raise ValueError, 'no images given'
        for row in range(self.tile_rows):
            for col in range(self.tile_cols):
                if not self.frames[col][row]:
                    im = PIL.Image.new(self.ref_image.mode, 
                                       self.ref_image.size, 
                                       0x00)
                    self.frames[col][row] = im
        if self.ref_image.mode == 'RGB':
            return self._generate_rgb()
        elif self.ref_image.mode == 'I':
            return self._generate_grayscale()
        raise ValueError, 'unsupported image mode "%s"' % self.ref_image.mode

    def _generate_grayscale(self):
        max_vals = []
        for row in range(self.tile_rows):
            for col in range(self.tile_cols):
                max_vals.append(self.frames[col][row].getextrema()[1])
        max_val = max(max_vals)
        scale = float(255) / max_val
        native_frame_side = max(self.ref_image.size)
        frame_side = min((native_frame_side, self.target_frame_side))
        im_size = (self.tile_cols * frame_side, self.tile_rows * frame_side)
        im = PIL.Image.new('L', im_size, 0x00)
        for row in range(self.tile_rows):
            for col in range(self.tile_cols):
                square = self._square(self.frames[col][row])
                square = square.point(lambda i: i * scale, 'L')
                bbox = (col*frame_side, 
                        row*frame_side, 
                        (col+1)*frame_side, 
                        (row+1)*frame_side)
                im.paste(square.resize((frame_side, frame_side)), bbox)
        return im

    def _generate_rgb(self):
        native_frame_side = max(self.ref_image.size)
        frame_side = min((native_frame_side, self.target_frame_side))
        im_size = (self.tile_cols * frame_side, self.tile_rows * frame_side)
        im = PIL.Image.new(self.ref_image.mode, im_size, 0x00)
        for row in range(self.tile_rows):
            for col in range(self.tile_cols):
                square = self._square(self.frames[col][row])
                bbox = (col*frame_side, 
                        row*frame_side, 
                        (col+1)*frame_side, 
                        (row+1)*frame_side)
                im.paste(square.resize((frame_side, frame_side)), bbox)
        return im

    def _square(self, im):
        "pad a frame with black to return a square image"
        side = max(im.size)
        left = (side - im.size[0]) / 2
        top = (side - im.size[1]) / 2
        square_im = PIL.Image.new(im.mode, (side, side), 0x00)
        square_im.paste(im, (left, top, left+im.size[0], top+im.size[1]))
        return square_im

def command_line_error(msg):
    sys.stderr.write('%s: %s\n' % (progname, msg))
    sys.stderr.write('run %s with no arguments for usage\n' % progname)
    return

def gen_dicom_generic(scan):
    if 'DICOM' not in scan.resources:
        raise GeneratorError('no DICOM resource')
    files = []
    for fname in scan.files('DICOM'):
        try:
            do = dicom.read_file(fname)
            files.append((do.InstanceNumber, fname))
        except GeneratorError:
            raise
        except:
            pass
    if not files:
        raise GeneratorError('no DICOM files found')
    files.sort(lambda a, b: cmp(a[0], b[0]))
    ti = TiledImage()
    for index in xrange(len(ti)):
        do = dicom.read_file(files[index*len(files)/len(ti)][1])
        data = do.pixel_array.astype('int32')
        im = PIL.Image.fromstring('I', (do.Columns, do.Rows), data)
        ti.add_frame(index, im)
    return ti.generate()

def gen_dicom_rgb(scan):
    if 'DICOM' not in scan.resources:
        raise GeneratorError('no DICOM resource')
    files = []
    for fname in scan.files('DICOM'):
        try:
            do = dicom.read_file(fname)
            if do.PhotometricInterpretation != 'RGB':
                raise GeneratorError('not RGB')
            files.append((do.InstanceNumber, fname))
        except GeneratorError:
            raise
        except:
            pass
    if not files:
        raise GeneratorError('no DICOM files found')
    files.sort(lambda a, b: cmp(a[0], b[0]))
    ti = TiledImage()
    for index in xrange(len(ti)):
        do = dicom.read_file(files[index*len(files)/len(ti)][1])
        im = PIL.Image.fromstring('RGB', (do.Columns, do.Rows), do.pixel_array)
        ti.add_frame(index, im)
    return ti.generate()

def gen_nifti_generic(scan):
    if 'NIfTI' not in scan.resources:
        raise GeneratorError('no NIfTI resource')
    vol = None
    for fname in scan.files('NIfTI'):
        try:
            vol = nibabel.load(fname)
        except GeneratorError:
            raise
        except:
            pass
        if vol:
            break
    if not vol:
        raise GeneratorError('no NIfTI files found')
    if len(vol.shape) != 3:
        raise GeneratorError('non-3D NIfTI not supported')
    if vol.get_data_dtype() != 'int16':
        raise GeneratorError('non-int16 NIfTI not supported')
    ti = TiledImage()
    if vol.shape[2] <= len(ti):
        slices = range(vol.shape[2])
    else:
        slices = [ i*vol.shape[2]/len(ti) for i in range(len(ti)) ]
    for (index, slice) in enumerate(slices):
        slice_data = vol.get_data()[:,:,slice].astype('int32')
        im = PIL.Image.fromstring('I', vol.shape[:2], slice_data)
        ti.add_frame(index, im)
    return ti.generate()

generators = [gen_dicom_rgb, gen_dicom_generic, gen_nifti_generic]

progname = os.path.basename(sys.argv.pop(0))

if not sys.argv:
    print
    print 'usage: %s <options>' % progname
    print
    print 'original options are:'
    print
    print '    -session <MR-session label> (ignored)'
    print '    -project <project that the MR-session belongs to> (ignored)'
    print '    -xnatId <MR-session ID>'
    print '    -host <XNAT base URI>'
    print '    -u <XNAT username>'
    print '    -pwd <XNAT password>'
    print '    -raw <create QC files for raw scans only> (ignored)'
    print
    print 'new options are:'
    print
    print '    -scan <comma-separated list of scans> (may occur more than once)'
    print '    -nooverwrite'
    print '    -test <directory>'
    print
    sys.exit(1)

session_id = None
base_uri = None
username = None
password = None
overwrite_flag = True
target_scans = None
test_dir = None

while sys.argv:
    option = sys.argv.pop(0)
    try:
        if option == '-session':
            sys.argv.pop(0)
        elif option == '-xnatId':
            session_id = sys.argv.pop(0)
        elif option == '-project':
            sys.argv.pop(0)
        elif option == '-host':
            base_uri = sys.argv.pop(0)
        elif option == '-u':
            username = sys.argv.pop(0)
        elif option == '-pwd':
            password = sys.argv.pop(0)
        elif option == '-raw':
            pass
        elif option == '-nooverwrite':
            overwrite_flag = False
        elif option == '-scan':
            if target_scans is None:
                target_scans = set()
            target_scans.update(sys.argv.pop(0).split(','))
        elif option == '-test':
            test_dir = sys.argv.pop(0)
        else:
            command_line_error('unknown option "%s"' % option)
            sys.exit(1)
    except IndexError:
        command_line_error('missing argument to %s' % option)
        sys.exit(1)

if test_dir is not None:
    print 'entering test mode'
    session_id = 'CS_E007'
    scans = []
    for subdir in os.listdir(test_dir):
        scans.append(DirScan(session_id, '%s/%s' % (test_dir, subdir)))
else:
    if not session_id:
        command_line_error('no session ID given')
        sys.exit(1)
    if not base_uri:
        command_line_error('no XNAT URI given')
        sys.exit(1)
    if not username:
        command_line_error('no username given')
        sys.exit(1)
    if not password:
        command_line_error('no password given')
        sys.exit(1)
    connection = xnat.Connection(base_uri, username, password)
    e = connection.find_experiment(session_id)
    scans = [ XNATScan(session_id, s) for s in e.scans.itervalues() ]

for scan in scans:
    if target_scans is not None:
        if scan.id not in target_scans:
            print '*', scan, '...skipping'
            continue
        target_scans.remove(scan.id)
    print '*', scan
    if not overwrite_flag:
        if 'SNAPSHOTS' in scan.resources:
            print 'SNAPSHOTS exists', scan
            continue
    im = None
    try:
        for f in generators:
            try:
                im = f(scan)
            except GeneratorError, e:
                print f, e.reason
            except StandardError:
                print f, 'error'
                traceback.print_exc()
            else:
                if not im:
                    print f, 'failed silently'
            if im:
                print f, 'success'
                break
        if not im:
            print 'no generator happy with', scan
        else:
            scan.save_image(im)
    finally:
        scan.remove_copies()

if target_scans is not None:
    print 'remaining', target_scans

if test_dir is None:
    connection.close()

sys.exit(0)

# eof
